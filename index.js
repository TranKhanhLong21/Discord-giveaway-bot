const { Client, GatewayIntentBits, EmbedBuilder } = require("discord.js");
const fs = require("fs");

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.GuildMembers
  ],
});

let giveaways = [];
const dataFile = "giveaways.json";

// Load d·ªØ li·ªáu
if (fs.existsSync(dataFile)) {
  giveaways = JSON.parse(fs.readFileSync(dataFile));
}

// L∆∞u d·ªØ li·ªáu
function saveGiveaways() {
  fs.writeFileSync(dataFile, JSON.stringify(giveaways, null, 2));
}

// L·ªánh t·∫°o giveaway: !ga <th·ªùi gian gi√¢y> <s·ªë ng∆∞·ªùi th·∫Øng> <gi·∫£i th∆∞·ªüng>
client.on("messageCreate", async (msg) => {
  if (!msg.content.startsWith("!ga")) return;

  const args = msg.content.split(" ");
  const duration = parseInt(args[1]) * 1000;
  const winnersCount = parseInt(args[2]);
  const prize = args.slice(3).join(" ");
  const endTime = Date.now() + duration;

  const embed = new EmbedBuilder()
    .setTitle("üéâ GIVEAWAY üéâ")
    .setDescription(`B·∫•m ‚ú® ƒë·ªÉ tham gia giveaway!\n\nüéÅ **Gi·∫£i th∆∞·ªüng:** ${prize}\nüèÜ **S·ªë ng∆∞·ªùi th·∫Øng:** ${winnersCount}\n‚è∞ **C√≤n l·∫°i:** <t:${Math.floor(endTime / 1000)}:R>`)
    .setColor("Pink")
    .setThumbnail(msg.author.displayAvatarURL());

  const giveawayMsg = await msg.channel.send({ embeds: [embed] });
  await giveawayMsg.react("‚ú®");

  giveaways.push({
    messageId: giveawayMsg.id,
    channelId: msg.channel.id,
    prize,
    winnersCount,
    endTime,
    users: []
  });

  saveGiveaways();
});

// Ng∆∞·ªùi d√πng tham gia
client.on("messageReactionAdd", async (reaction, user) => {
  if (user.bot) return;
  const giveaway = giveaways.find(g => g.messageId === reaction.message.id);
  if (giveaway && reaction.emoji.name === "‚ú®") {
    if (!giveaway.users.includes(user.id)) {
      giveaway.users.push(user.id);
      saveGiveaways();
    }
  }
});

// Check winner m·ªói 5s
setInterval(async () => {
  const now = Date.now();
  for (const g of giveaways) {
    if (g.endTime <= now && !g.ended) {
      g.ended = true;
      const channel = await client.channels.fetch(g.channelId);
      const message = await channel.messages.fetch(g.messageId);
      const winners = [];

      for (let i = 0; i < g.winnersCount; i++) {
        const winner = g.users[Math.floor(Math.random() * g.users.length)];
        if (winner && !winners.includes(winner)) winners.push(winner);
      }

      channel.send(`üéâ Giveaway k·∫øt th√∫c!\nüèÜ Ng∆∞·ªùi th·∫Øng: ${winners.map(w => `<@${w}>`).join(", ") || "Kh√¥ng c√≥ ai"}\nüéÅ Gi·∫£i th∆∞·ªüng: **${g.prize}**`);
      saveGiveaways();
    }
  }
}, 5000);

client.login(process.env.DISCORD_TOKEN);  if (unit === "s") return n * 1000;
  if (unit === "m") return n * 60 * 1000;
  if (unit === "h") return n * 60 * 60 * 1000;
  if (unit === "d") return n * 24 * 60 * 60 * 1000;
  return null;
}

// T·∫°o embed gi·ªëng m·∫´u: title, thumbnail, fields, footer
function makeGiveawayEmbed(prize, winnersCount, endAt, host) {
  const embed = new EmbedBuilder()
    .setColor(0xffb6c1) // m√†u pink nh·∫π
    .setTitle(`‚ú® GIVEAWAY ‚ú®`)
    .setDescription(`B·∫•m ${JOIN_EMOJI} ƒë·ªÉ tham gia giveaway!`)
    .setThumbnail(host.displayAvatarURL({ extension: "png", size: 512 }))
    .addFields(
      { name: "‚è≥ C√≤n l·∫°i", value: `<t:${Math.floor(endAt/1000)}:R>`, inline: false },
      { name: "üéÅ Gi·∫£i th∆∞·ªüng", value: `${prize}`, inline: false },
      { name: "üë• S·ªë ng∆∞·ªùi th·∫Øng", value: `${winnersCount}`, inline: false }
    )
    .setFooter({ text: `L√†m b·ªüi: ${host.tag}`, iconURL: host.displayAvatarURL({ size: 32 }) })
    .setTimestamp(endAt);
  return embed;
}

async function scheduleGiveaway(gw) {
  // n·∫øu ƒë√£ k·∫øt th√∫c th√¨ end lu√¥n
  const delay = gw.endAt - Date.now();
  if (delay <= 0) {
    await finishGiveawayByData(gw).catch(console.error);
    return;
  }
  setTimeout(async () => {
    await finishGiveawayByData(gw).catch(console.error);
  }, delay);
}

async function finishGiveawayByData(gw) {
  try {
    const channel = await client.channels.fetch(gw.channelId).catch(() => null);
    if (!channel) {
      // x√≥a n·∫øu channel kh√¥ng t·ªìn t·∫°i
      giveaways = giveaways.filter(x => x.messageId !== gw.messageId);
      saveDB();
      return;
    }
    const msg = await channel.messages.fetch(gw.messageId).catch(() => null);
    if (!msg) {
      giveaways = giveaways.filter(x => x.messageId !== gw.messageId);
      saveDB();
      return;
    }

    const reaction = msg.reactions.cache.get(JOIN_EMOJI) || msg.reactions.cache.find(r => r.emoji.name === JOIN_EMOJI);
    if (!reaction) {
      await channel.send("‚ùå Kh√¥ng c√≥ ai tham gia giveaway.");
      giveaways = giveaways.filter(x => x.messageId !== gw.messageId);
      saveDB();
      return;
    }

    const users = await reaction.users.fetch();
    const participants = users.filter(u => !u.bot).map(u => u.id);
    if (participants.length === 0) {
      await channel.send("üò¢ Kh√¥ng c√≥ ai tham gia giveaway.");
      giveaways = giveaways.filter(x => x.messageId !== gw.messageId);
      saveDB();
      return;
    }

    const winners = [];
    while (winners.length < Math.min(gw.winnersCount, participants.length)) {
      const pick = participants[Math.floor(Math.random() * participants.length)];
      if (!winners.includes(pick)) winners.push(pick);
    }

    await channel.send(`üéâ Ch√∫c m·ª´ng ${winners.map(id => `<@${id}>`).join(", ")} ƒë√£ th·∫Øng **${gw.prize}**!`);
    // DM winners (n·∫øu mu·ªën)
    for (const id of winners) {
      try {
        const user = await client.users.fetch(id);
        await user.send(`üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ th·∫Øng **${gw.prize}** trong server **${channel.guild.name}**.`);
      } catch (e) {
        // kh√¥ng √©p ph·∫£i DM ƒë∆∞·ª£c
      }
    }

    // x√≥a kh·ªèi DB
    giveaways = giveaways.filter(x => x.messageId !== gw.messageId);
    saveDB();
  } catch (err) {
    console.error("finishGiveaway error:", err);
  }
}

// Khi bot b·∫≠t l·∫°i, schedule c√°c giveaway c√≤n s·ªëng
client.once("ready", async () => {
  console.log("Bot ready:", client.user.tag);
  for (const gw of giveaways.slice()) {
    // ƒë·∫£m b·∫£o guild & channel t·ªìn t·∫°i
    scheduleGiveaway(gw);
  }
});

client.on("messageCreate", async (message) => {
  if (message.author.bot) return;
  if (!message.content.startsWith(PREFIX)) return;

  const args = message.content.slice(PREFIX.length).trim().split(/ +/);
  // C√∫ ph√°p: !ga <time> <winners> <prize...>
  // V√≠ d·ª•: !ga 60s 1 Nitro
  const timeStr = args[0];
  const winnersCount = parseInt(args[1], 10);
  const prize = args.slice(2).join(" ");
  if (!timeStr || !winnersCount || !prize) {
    return message.reply("‚ùå C√∫ ph√°p: `!ga <time> <winners> <prize>`\nV√≠ d·ª•: `!ga 60s 1 Nitro` (time: 30s, 5m, 2h, 1d)");
  }

  const duration = msParse(timeStr);
  if (!duration) return message.reply("‚ùå Th·ªùi gian kh√¥ng h·ª£p l·ªá. D√πng s/m/h/d (v√≠ d·ª• 30s, 5m, 2h).");

  const endAt = Date.now() + duration;
  const embed = makeGiveawayEmbed(prize, winnersCount, endAt, message.author);
  const sent = await message.channel.send({ embeds: [embed] });

  // React b·∫±ng emoji Unicode an to√†n
  try {
    await sent.react(JOIN_EMOJI);
  } catch (err) {
    console.error("React failed:", err);
    message.reply("‚ö†Ô∏è Bot kh√¥ng th·ªÉ react emoji. H√£y ch·∫Øc bot c√≥ quy·ªÅn Add Reactions v√† Use External Emojis (n·∫øu emoji custom).");
  }

  // L∆∞u giveaway
  const gwData = {
    messageId: sent.id,
    channelId: message.channel.id,
    guildId: message.guild.id,
    prize,
    winnersCount,
    endAt,
    hostId: message.author.id
  };
  giveaways.push(gwData);
  saveDB();

  scheduleGiveaway(gwData);

  // Tr·∫£ v·ªÅ messageId ƒë·ªÉ admin c√≥ th·ªÉ end th·ªß c√¥ng n·∫øu mu·ªën
  message.reply(`‚úÖ Giveaway t·∫°o th√†nh c√¥ng! ID: \`${sent.id}\`. Bot s·∫Ω k·∫øt th√∫c t·ª± ƒë·ªông <t:${Math.floor(endAt/1000)}:R>.`);
});

// T·ª± end b·∫±ng l·ªánh (admin): !ga end <messageId>
client.on("messageCreate", async (message) => {
  if (message.author.bot) return;
  if (!message.content.startsWith(PREFIX)) return;
  const args = message.content.slice(PREFIX.length).trim().split(/ +/);
  if (args[0] === "end" && args[1]) {
    const id = args[1];
    const gw = giveaways.find(x => x.messageId === id);
    if (!gw) return message.reply("‚ùå Kh√¥ng t√¨m th·∫•y giveaway v·ªõi messageId ƒë√≥.");
    await finishGiveawayByData(gw);
    return message.reply("üîî Giveaway ƒë√£ ƒë∆∞·ª£c k·∫øt th√∫c (manual).");
  }
});

client.login(TOKEN);
  if (cmd === "ga") {
    const time = ms(args[0]);
    const winners = parseInt(args[1]);
    const prize = args.slice(2).join(" ");

    if (!time || !winners || !prize) {
      return message.reply("‚ùå C√∫ ph√°p: `!ga <time> <winners> <prize>`\nVD: `!ga 60s 1 Nitro`");
    }

    const giveawayMsg = await message.channel.send(
      `üéâ **GIVEAWAY** üéâ\n\nGi·∫£i th∆∞·ªüng: **${prize}**\nS·ªë ng∆∞·ªùi th·∫Øng: **${winners}**\nTh·ªùi gian: **${args[0]}**\n\nReact v·ªõi ${EMOJI_JOIN} ƒë·ªÉ tham gia!`
    );

    try {
      await giveawayMsg.react(EMOJI_JOIN);
    } catch (err) {
      return message.reply("‚ö†Ô∏è Bot kh√¥ng react ƒë∆∞·ª£c emoji n√†y, h√£y ch·∫Øc ch·∫Øn bot c√≥ trong server ch·ª©a emoji.");
    }

    const newGiveaway = {
      messageId: giveawayMsg.id,
      channelId: message.channel.id,
      prize,
      winners,
      endAt: Date.now() + time
    };

    giveaways.push(newGiveaway);
    saveGiveaways();

    setTimeout(async () => {
      const channel = await client.channels.fetch(newGiveaway.channelId);
      const msg = await channel.messages.fetch(newGiveaway.messageId);

      const reaction = msg.reactions.cache.find(r => r.emoji.toString() === EMOJI_JOIN);
      if (!reaction) return channel.send("‚ùå Kh√¥ng t√¨m th·∫•y reaction cho giveaway.");

      const users = await reaction.users.fetch();
      const participants = users.filter(u => !u.bot).map(u => u);

      if (participants.length === 0) {
        channel.send("‚ùå Kh√¥ng c√≥ ai tham gia giveaway.");
        return;
      }

      const winnersPicked = [];
      for (let i = 0; i < newGiveaway.winners; i++) {
        const winner = participants[Math.floor(Math.random() * participants.length)];
        if (!winnersPicked.includes(winner)) {
          winnersPicked.push(winner);
        }
      }

      channel.send(`üéä Ch√∫c m·ª´ng ${winnersPicked.map(w => w.toString()).join(", ")} ƒë√£ th·∫Øng **${newGiveaway.prize}** üéä`);
    }, time);
  }
});

function ms(str) {
  const match = str.match(/(\d+)([smhd])/);
  if (!match) return null;
  const num = parseInt(match[1]);
  const unit = match[2];
  if (unit === "s") return num * 1000;
  if (unit === "m") return num * 60 * 1000;
  if (unit === "h") return num * 60 * 60 * 1000;
  if (unit === "d") return num * 24 * 60 * 60 * 1000;
  return null;
}

client.login(process.env.DISCORD_TOKEN);
}
